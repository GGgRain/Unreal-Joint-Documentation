"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3747],{1928:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>d,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=n(5893),o=n(1151);const i={title:"API Reference",sidebar_position:2,toc_min_heading_level:2,toc_max_heading_level:6},d=void 0,s={id:"guide_docs/Joint/API_Reference/API_Reference",title:"API Reference",description:"Joint API Reference",source:"@site/docs/guide_docs/Joint/API_Reference/API_Reference.md",sourceDirName:"guide_docs/Joint/API_Reference",slug:"/guide_docs/Joint/API_Reference/",permalink:"/Unreal-Joint-Documentation/ko-kr/docs/guide_docs/Joint/API_Reference/",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/guide_docs/Joint/API_Reference/API_Reference.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"API Reference",sidebar_position:2,toc_min_heading_level:2,toc_max_heading_level:6},sidebar:"GuideSidebar",previous:{title:"QuickStart",permalink:"/Unreal-Joint-Documentation/ko-kr/docs/guide_docs/Joint/QuickStart/"},next:{title:"Installation",permalink:"/Unreal-Joint-Documentation/ko-kr/docs/guide_docs/Joint-Native/Installation/"}},r={},l=[{value:"Joint API Reference",id:"joint-api-reference",level:2},{value:"Dialogue Manager",id:"dialogue-manager",level:2},{value:"Finding Base Node on Dialogue Manager",id:"finding-base-node-on-dialogue-manager",level:3},{value:"Changing the starting point on the runtime",id:"changing-the-starting-point-on-the-runtime",level:3},{value:"About The Root Node",id:"about-the-root-node",level:3},{value:"Dialogue Manager itself is not replicated",id:"dialogue-manager-itself-is-not-replicated",level:3},{value:"Dialogue Actor",id:"dialogue-actor",level:2},{value:"Playback Delegates",id:"playback-delegates",level:3},{value:"Networking",id:"networking",level:3},{value:"GAS Supports",id:"gas-supports",level:3},{value:"Joint Subsystem",id:"joint-subsystem",level:2},{value:"Finding Dialogue",id:"finding-dialogue",level:3},{value:"Global Dialogue Start &amp; End Delegate",id:"global-dialogue-start--end-delegate",level:3},{value:"Dialogue Node",id:"dialogue-node",level:2},{value:"Playback Delegates",id:"playback-delegates-1",level:3},{value:"Graph Node Customization",id:"graph-node-customization",level:3},{value:"Playback and Life-cycle of Dialogue Nodes",id:"playback-and-life-cycle-of-dialogue-nodes",level:3},{value:"Begin Play",id:"begin-play",level:4},{value:"End Play",id:"end-play",level:4},{value:"Pending",id:"pending",level:4},{value:"Base Node (Foundation Node)",id:"base-node-foundation-node",level:3},{value:"(Important) Unit of Network Replication of Playback Synchronization",id:"important-unit-of-network-replication-of-playback-synchronization",level:4},{value:"Fragment",id:"fragment",level:3},{value:"Networking",id:"networking-1",level:4},{value:"Manager Fragments",id:"manager-fragments",level:3},{value:"Best Way to Make Global Storage",id:"best-way-to-make-global-storage",level:4},{value:"Dialogue Editor Graph Node",id:"dialogue-editor-graph-node",level:2},{value:"Node instance Related",id:"node-instance-related",level:3},{value:"Sub Node Related",id:"sub-node-related",level:3},{value:"Pin Related",id:"pin-related",level:3},{value:"Graph Node Slate Related",id:"graph-node-slate-related",level:3}];function h(e){const t={admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"joint-api-reference",children:"Joint API Reference"}),"\n",(0,a.jsx)(t.p,{children:"Here is the place where everything fundamental about Joint is explained at. This documentation will be updated and reinforced through the future updates."}),"\n",(0,a.jsx)(t.admonition,{type:"warning",children:(0,a.jsx)(t.p,{children:"Be careful, we are not aiming to explain those stuffs in tutorial mood, but just throw the things we considered on the development, just like a nerd who tells a stuff that only he knows about. \ud83e\udd13"})}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsx)(t.p,{children:"Also, the sample assets in Joint Native will also greatly help you to understand the concept of the framework. Please consider checking it out."})}),"\n",(0,a.jsx)(t.h2,{id:"dialogue-manager",children:"Dialogue Manager"}),"\n",(0,a.jsx)(t.p,{children:"Dialogue Manager is an asset type that refers to a single set of conversation on project. Dialogue manager is the object that you store all the nodes in."}),"\n",(0,a.jsx)(t.h3,{id:"finding-base-node-on-dialogue-manager",children:"Finding Base Node on Dialogue Manager"}),"\n",(0,a.jsxs)(t.p,{children:["Dialogue Manager contains all the base nodes in the graph in the ",(0,a.jsx)(t.strong,{children:"Nodes"})," property. You can access it on both C++ and BP on the runtime.\nYou can iterate this array and find the nodes you need, most common method to get the node is simply comparing its GUID. We already support finding nodes with Guid with FindBaseNodeWithGuid().\nAlso comparing its name to identify it is also possible, but not recommended way to go."]}),"\n",(0,a.jsx)(t.h3,{id:"changing-the-starting-point-on-the-runtime",children:"Changing the starting point on the runtime"}),"\n",(0,a.jsxs)(t.p,{children:["When you play a dialogue manager, the dialogue instance will pick up the first node on the ",(0,a.jsx)(t.strong,{children:"Start Node"})," list and play the dialogue from there.\nYou can manually change this property on the runtime before you start off the dialogue to change the point where you want to start your dialogue from. ",(0,a.jsx)(t.strong,{children:"Notice the list must take base nodes only."})]}),"\n",(0,a.jsx)(t.h3,{id:"about-the-root-node",children:"About The Root Node"}),"\n",(0,a.jsxs)(t.p,{children:["The node that you see at first when you first opened the dialogue manager is the root node of that dialogue manager.\nRoot node also can have fragments, and the fragments the root node has are called ",(0,a.jsx)(t.strong,{children:"Manager Fragment"}),"."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"img.png",src:n(2970).Z+"",width:"1107",height:"1076"})}),"\n",(0,a.jsx)(t.p,{children:"Manager Fragments are the perfect place to store the data you need throughout the dialogue playback because it is really easy to access on every dialogue nodes on the graph because Dialogue Manager provide a tons of functions to find a manager fragment you need.\nThings about the Manager Fragments are well described on the Fragment part."}),"\n",(0,a.jsxs)(t.p,{children:["Root node is technically not a dialogue node, because it doesn't have dialogue node instance (",(0,a.jsx)(t.code,{children:"UDialogueNodeBase"}),") inside."]}),"\n",(0,a.jsx)(t.h3,{id:"dialogue-manager-itself-is-not-replicated",children:"Dialogue Manager itself is not replicated"}),"\n",(0,a.jsx)(t.p,{children:"Actually, Dialogue Manager itself is not replicated through the network. Only the nodes are replicated via Dialogue Actor."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"dialogue-actor",children:"Dialogue Actor"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Dialogue Actor"})," is an actor object that actually plays a dialogue with a provided dialogue manager."]}),"\n",(0,a.jsxs)(t.p,{children:["Dialogue Actor has ",(0,a.jsx)(t.strong,{children:"DialogueGuid"})," property. You can find dialogue actor with this Guid with ",(0,a.jsx)(t.code,{children:"FindDialogue()"})," on Joint Subsystem."]}),"\n",(0,a.jsxs)(t.p,{children:["You can get the base node the dialogue actor is currently playing with ",(0,a.jsx)(t.code,{children:"GetPlayingDialogueNode()"})]}),"\n",(0,a.jsx)(t.h3,{id:"playback-delegates",children:"Playback Delegates"}),"\n",(0,a.jsx)(t.p,{children:"Dialogue Actor provides delegates related to the node's playback and dialogue's playback."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"OnDialogueStartedDelegate : Will be executed when the dialogue has been started."}),"\n",(0,a.jsx)(t.li,{children:"OnDialogueEndedDelegate : Will be executed when the dialogue has been ended."}),"\n",(0,a.jsx)(t.li,{children:"OnDialogueBaseNodePlayedDelegate : Will be executed when the dialogue has played a new base node."}),"\n",(0,a.jsx)(t.li,{children:"OnDialogueNodeBeginPlayDelegate : Will be executed whenever a fragment or a base node has been played."}),"\n",(0,a.jsx)(t.li,{children:"OnDialogueNodeEndPlayDelegate : Will be executed whenever a fragment or a base node has been ended."}),"\n",(0,a.jsx)(t.li,{children:"OnDialogueNodePendingDelegate : Will be executed whenever a fragment or a base node has been marked as pending."}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"networking",children:"Networking"}),"\n",(0,a.jsx)(t.p,{children:"Dialogue Actor is where all the network related actions including replication happen."}),"\n",(0,a.jsx)(t.p,{children:"Check out the networking related functions."}),"\n",(0,a.jsx)(t.h3,{id:"gas-supports",children:"GAS Supports"}),"\n",(0,a.jsxs)(t.p,{children:["Dialogue Actor has a ",(0,a.jsx)(t.code,{children:"UAbilitySystemComponent"})," by default, and due to that, you can use a lot of GAS related things with the dialogue actor."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'/**\n* A component for the GAS implementation.\n* A Dialogue instance actor can have gameplay ability by itself, and it can be used in multiple situations.\n*/\nUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="GAS")\nUAbilitySystemComponent* AbilitySystemComponent;\n\npublic:\nUFUNCTION(BlueprintPure, Category="GAS")\nUAbilitySystemComponent* GetAbilitySystemComponent() const;\n\n/**\n * Actual code where the node instance use to implement a default AbilitySystemComponent sub object.\n * Override this function to implement the AbilitySystemComponent with the subclass you desire.\n */\nvirtual void ImplementAbilitySystemComponent();\n\n'})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"joint-subsystem",children:"Joint Subsystem"}),"\n",(0,a.jsx)(t.p,{children:"Joint Subsystem is a gameinstance subsystem that provides some helpful features you can utilize."}),"\n",(0,a.jsx)(t.h3,{id:"finding-dialogue",children:"Finding Dialogue"}),"\n",(0,a.jsxs)(t.p,{children:["You can find existing dialogue instance actor with ",(0,a.jsx)(t.code,{children:"FindDialogue, GetAllDialogues"}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"global-dialogue-start--end-delegate",children:"Global Dialogue Start & End Delegate"}),"\n",(0,a.jsxs)(t.p,{children:["It also provides delegates for Dialogue begin & end events, ",(0,a.jsx)(t.code,{children:"OnDialogueBeginDelegate, OnDialogueEndDelegate"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"You can access the subsystem on both c++ and bp, and bind events to the delegate to get the dialogues that has been played on the session."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"img_6.png",src:n(80).Z+"",width:"760",height:"459"})}),"\n",(0,a.jsxs)(t.p,{children:["Also, you can get the dialogue instances that has been played in the same frame with ",(0,a.jsx)(t.code,{children:"GetDialoguesGuidStartedOnThisFrame, GetDialoguesGuidEndedOnThisFrame"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Those are useful when you want to check out whether there are any dialogues that have been played & ended just before you assign your events on the delegates above."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"img_8.png",src:n(1745).Z+"",width:"541",height:"350"})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"dialogue-node",children:"Dialogue Node"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Dialogue Node"})," is a type of object that has been designed to execute its unique events and contain data for the graph."]}),"\n",(0,a.jsx)(t.p,{children:"Dialogue Fragment, Base Nodes are subclasses of Dialogue node."}),"\n",(0,a.jsxs)(t.p,{children:["You can access the node that the node is attached at with ",(0,a.jsx)(t.code,{children:"GetParentNode()"}),", and the highest parent on the hierarchy with ",(0,a.jsx)(t.code,{children:"GetParentmostNode()"}),", or all the parent node on hierarchy with ",(0,a.jsx)(t.code,{children:"GetParentNodesOnHierarchy()"})]}),"\n",(0,a.jsxs)(t.p,{children:["You can get the dialogue manager that owns the dialogue node with ",(0,a.jsx)(t.code,{children:"GetDialogueManager()"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["You can get the dialogue actor that is hosting the dialogue in the world with ",(0,a.jsx)(t.code,{children:"GetHostingDialogueInstance()"})]}),"\n",(0,a.jsxs)(t.p,{children:["Dialogue Nodes can have Gameplay Tags. the container property is named ",(0,a.jsx)(t.strong,{children:"NodeTags"}),". This is useful for the identification."]}),"\n",(0,a.jsx)(t.p,{children:"You can get the children sub nodes with those functions :"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"FindFragmentWithTag"}),"\n",(0,a.jsx)(t.li,{children:"FindFragmentsWithTag"}),"\n",(0,a.jsx)(t.li,{children:"FindFragmentWithAnyTags"}),"\n",(0,a.jsx)(t.li,{children:"FindFragmentsWithAnyTags"}),"\n",(0,a.jsx)(t.li,{children:"FindFragmentsWithAllTags"}),"\n",(0,a.jsx)(t.li,{children:"FindFragmentWithAllTags"}),"\n",(0,a.jsx)(t.li,{children:"FindFragmentWithGuid"}),"\n",(0,a.jsx)(t.li,{children:"FindFragmentByClass"}),"\n",(0,a.jsx)(t.li,{children:"FindFragmentsByClass"}),"\n",(0,a.jsx)(t.li,{children:"GetAllFragments"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"You can get the children sub nodes all over the lower hierarchy (it will also search through the sub nodes' sub nodes) with those functions :"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"FindFragmentWithTagOnLowerHierarchy"}),"\n",(0,a.jsx)(t.li,{children:"FindFragmentsWithTagOnLowerHierarchy"}),"\n",(0,a.jsx)(t.li,{children:"FindFragmentWithAnyTagsOnLowerHierarchy"}),"\n",(0,a.jsx)(t.li,{children:"FindFragmentsWithAnyTagsOnLowerHierarchy"}),"\n",(0,a.jsx)(t.li,{children:"FindFragmentWithAllTagsOnLowerHierarchy"}),"\n",(0,a.jsx)(t.li,{children:"FindFragmentsWithAllTagsOnLowerHierarchy"}),"\n",(0,a.jsx)(t.li,{children:"FindFragmentWithGuidOnLowerHierarchy"}),"\n",(0,a.jsx)(t.li,{children:"FindFragmentByClassOnLowerHierarchy"}),"\n",(0,a.jsx)(t.li,{children:"FindFragmentsByClassOnLowerHierarchy"}),"\n",(0,a.jsx)(t.li,{children:"GetAllFragmentsOnLowerHierarchy"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"playback-delegates-1",children:"Playback Delegates"}),"\n",(0,a.jsx)(t.p,{children:"Dialogue node provides delegates related to the node's playback."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"OnDialogueNodeBeginDelegate : Will be executed when the node has been played."}),"\n",(0,a.jsx)(t.li,{children:"OnDialogueNodeEndDelegate : Will be executed  when the node has been ended."}),"\n",(0,a.jsx)(t.li,{children:"OnDialogueNodeMarkedAsPendingDelegate : Will be executed when the node has been marked as pending."}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"graph-node-customization",children:"Graph Node Customization"}),"\n",(0,a.jsxs)(t.p,{children:["Dialogue Nodes are displayed on the graph while being wrapped by ",(0,a.jsxs)(t.strong,{children:["Dialogue Editor Graph Node (",(0,a.jsx)(t.code,{children:"UDialogueEdGraphNode"}),")"]})," that supports that type of the dialogue node."]}),"\n",(0,a.jsx)(t.p,{children:"To fully customize the visual representation on the graph, you must define custom Dialogue Editor Graph Node for your fragment, but if that is not possible, you can also use this to enhance the productivity."}),"\n",(0,a.jsxs)(t.p,{children:["If you go to the ",(0,a.jsx)(t.strong,{children:"Class Default"})," of the dialogue node class, then you will see those properties there."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"img_3.png",src:n(2243).Z+"",width:"1038",height:"470"})}),"\n",(0,a.jsxs)(t.p,{children:["Add new element on the ",(0,a.jsx)(t.strong,{children:"Property Data for Simple Display on Graph Node"})," array and fill out the name of the property you want to show on the graph node."]}),"\n",(0,a.jsx)(t.p,{children:"Then you will see this small section that displays the property you wanted."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"img_4.png",src:n(2891).Z+"",width:"612",height:"338"})}),"\n",(0,a.jsxs)(t.p,{children:["Also you can specify the color of the node to use in the graph here. Change the value of ",(0,a.jsx)(t.strong,{children:"Graph Node Iconic Color"})," and set ",(0,a.jsx)(t.strong,{children:"Use Specified Graph Node Iconic Color"})," to true."]}),"\n",(0,a.jsx)(t.h3,{id:"playback-and-life-cycle-of-dialogue-nodes",children:"Playback and Life-cycle of Dialogue Nodes"}),"\n",(0,a.jsx)(t.h4,{id:"begin-play",children:"Begin Play"}),"\n",(0,a.jsx)(t.p,{children:"When Dialogue Nodes begin played on the graph, it iterates and plays the sub nodes. (fragments) It looks like this on the code."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"img_2.png",src:n(6565).Z+"",width:"1237",height:"334"})}),"\n",(0,a.jsx)(t.p,{children:"This action is overridable, but applied on every base nodes and any normal fragments on the system by default."}),"\n",(0,a.jsx)(t.p,{children:"Due to this, when dialogue node has been played the order of the dialogue nodes begin will be as following."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"img_1.png",src:n(5158).Z+"",width:"1050",height:"396"})}),"\n",(0,a.jsx)(t.p,{children:"The number in the bracket is the actual order the node begins played."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Another important thing you must realize on this is that every node will be triggered without waiting the previous node to finish by default. It means that the begin play action of the dialogue nodes is not delayed by the other nodes by default."})}),"\n",(0,a.jsx)(t.p,{children:"To achieve the delay effect on the node execution you override the default action on begin play. This is already implemented through the Sequence Node on Joint Native."}),"\n",(0,a.jsx)(t.p,{children:"See how we implemented that feature on the sequence node."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"void UDF_Sequence::SelectNodeAsPlayingNode(UDialogueNodeBase* SubNode)\n{\n\tSubNode->OnDialogueNodeMarkedAsPendingDelegate.AddDynamic(this, &UDF_Sequence::OnSubNodePending);\n\n\tGetHostingDialogueInstance()->RequestNodeBeginPlay(SubNode);\n}\n\nvoid UDF_Sequence::PlayNextSubNode()\n{\n\tif (!GetHostingDialogueInstance().IsValid()) return;\n\n\tCurrentIndex++;\n\n\twhile (SubNodes.IsValidIndex(CurrentIndex))\n\t{\n\t\tUDialogueNodeBase* SubNode = SubNodes[CurrentIndex];\n\n\t\tif (SubNode != nullptr)\n\t\t{\n\t\t\tSelectNodeAsPlayingNode(SubNode);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tCurrentIndex++;\n\t}\n\n\n\tif (!SubNodes.IsValidIndex(CurrentIndex))\n\t{\n\t\tGetHostingDialogueInstance()->RequestNodeEndPlay(this);\n\t}\n}\n\n\nvoid UDF_Sequence::OnNodeBeginPlay_Implementation()\n{\n\t//reset\n\tCurrentIndex = INDEX_NONE;\n\t\n\tPlayNextSubNode();\n}\n\nvoid UDF_Sequence::OnSubNodePending(UDialogueNodeBase* InNode)\n{\n\tif (InNode == nullptr) return;\n\n\tInNode->OnDialogueNodeMarkedAsPendingDelegate.RemoveDynamic(this, &UDF_Sequence::OnSubNodePending);\n\n\tPlayNextSubNode();\n}\n\n"})}),"\n",(0,a.jsx)(t.h4,{id:"end-play",children:"End Play"}),"\n",(0,a.jsx)(t.p,{children:"And End Play of the dialogue nodes are almost identical with the begin play action. It iterates the sub nodes on hierarchy in the same order, and trigger NodeEndPlay()."}),"\n",(0,a.jsx)(t.h4,{id:"pending",children:"Pending"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Pending"})," means the state of node that has played all the necessary logic to execute, ready to finish the node playback anytime the parent node want,\nand no longer holding the playback."]}),"\n",(0,a.jsx)(t.p,{children:"This is useful when you want to make a node that must continue its action until the whole node ends, but don't want to halt or hold the playback."}),"\n",(0,a.jsxs)(t.p,{children:["You can mark the node as pending by force by executing ",(0,a.jsx)(t.code,{children:"MarkNodePendingByForce()"})," on the runtime."]}),"\n",(0,a.jsx)(t.p,{children:"And nodes will be marked as pending whenever they become end played."}),"\n",(0,a.jsx)(t.p,{children:"Also, Nodes will be tested whether to be marked as pending whenever any of the sub nodes (fragments) is marked as pending."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"void UDialogueNodeBase::MarkNodePending()\n{\n\t//Don't end again if once ended before.\n\tif (IsNodePending()) return;\n\n\tbIsNodePending = true;\n\n\t//Broadcast OnDialogueNodeMarkedAsPendingDelegate Action.\n\tif (OnDialogueNodeMarkedAsPendingDelegate.IsBound())\n\t{\n\t\tOnDialogueNodeMarkedAsPendingDelegate.Broadcast(this);\n\t}\n\t\n\tGetHostingDialogueInstance()->NotifyNodePending(this);\n\n\tif (ParentNode) ParentNode->MarkNodePendingIfNeeded();\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"And by default, it will be marked as pending when all the sub nodes are marked as pending, and you can control this behavior by overriding that function."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"void UDialogueNodeBase::MarkNodePendingIfNeeded()\n{\n\tif (CheckCanMarkNodeAsPending())\n\t{\n\t\t//Mark pending.\n\t\tMarkNodePendingByForce();\n\t}\n}\n\n...\n\n\nbool UDialogueNodeBase::CheckCanMarkNodeAsPending_Implementation()\n{\n\tfor (const UDialogueNodeBase* SubNode : SubNodes)\n\t{\n\t\tif (!SubNode) continue;\n\n\t\tif (!SubNode->IsNodePending())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"base-node-foundation-node",children:"Base Node (Foundation Node)"}),"\n",(0,a.jsx)(t.h4,{id:"important-unit-of-network-replication-of-playback-synchronization",children:"(Important) Unit of Network Replication of Playback Synchronization"}),"\n",(0,a.jsxs)(t.p,{children:["This is ",(0,a.jsx)(t.strong,{children:"EXTREMELY"})," important to understand when you are going to use Joint on the multiplayer game."]}),"\n",(0,a.jsxs)(t.p,{children:["Fragment's properties can be replicated for sure, ",(0,a.jsx)(t.strong,{children:"but the playback of it is not replicated through the network. All the local clients and the server will play the fragments on its own local playback."}),"\nThis means the node's begin play events and end play, pending events will not be replicated (They are not RPC functions at the first place.), and also the flag variables for them will not be replicated by default."]}),"\n",(0,a.jsx)(t.p,{children:"This let you trigger different fragments for each session. The server can trigger its own unique fragments that must be played only on the server, and clients can trigger the nodes for the clients. Also this let you able to exists the players from multiple localization culture even if the asset they use has been slightly changed from the original asset."}),"\n",(0,a.jsxs)(t.p,{children:["But there is only one type of nodes that the playback is replicated. ",(0,a.jsx)(t.strong,{children:"Base Node"}),". The dialogue actor on the host side (specifically the session that has the authority over the dialogue instance) control all the playback of the base nodes."]}),"\n",(0,a.jsx)(t.p,{children:"Even if the clients finishes the playback of the dialogues, they can not move to the next node in local. And also even if they didn't finish the playback of the base node locally, if the host want to move to the next node, then all the clients will move to the node server specified."}),"\n",(0,a.jsx)(t.h3,{id:"fragment",children:"Fragment"}),"\n",(0,a.jsx)(t.p,{children:"Fragment is a type of node that has been designed to be attached on the other nodes to execute its unique events and contain data for the graph and its parent nodes."}),"\n",(0,a.jsx)(t.h4,{id:"networking-1",children:"Networking"}),"\n",(0,a.jsxs)(t.p,{children:["Fragments' properties will be replicated, but only when the ",(0,a.jsx)(t.strong,{children:"bReplicate"})," flag is true. Use ",(0,a.jsx)(t.code,{children:"SetReplicates()"})," to change whether to replicate the node on the runtime."]}),"\n",(0,a.jsx)(t.p,{children:"And fragments can have RPC functions, but those must be executed through the external actor that has net authority if the session is not the host of the game session. (In most cases, it will be a player controller.)"}),"\n",(0,a.jsx)(t.h3,{id:"manager-fragments",children:"Manager Fragments"}),"\n",(0,a.jsx)(t.h4,{id:"best-way-to-make-global-storage",children:"Best Way to Make Global Storage"}),"\n",(0,a.jsx)(t.p,{children:"Manager Fragments are the most effective methods for data storages that can be used throughout the playback, since their life-cycle will follow the dialogue instance's life-cycle and they are the easiest fragments to find on the graph on the performance wise."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"img_5.png",src:n(258).Z+"",width:"1112",height:"808"})}),"\n",(0,a.jsxs)(t.p,{children:["You can find those fragments on the ",(0,a.jsx)(t.strong,{children:"Dialogue Manager"})," with the functions related to the manager fragments all over the graph because all dialogue nodes have GetDialogueManager() function, and dialogue manager has a tons of Manager fragment version of find ~~ fragments functions you can use to get the manager fragments."]}),"\n",(0,a.jsx)(t.p,{children:"Also, Manager fragment is good to be a fragment that must be accessible on the outside of the dialogue graph. You can simply grab the node you want with tags, name, class etc."}),"\n",(0,a.jsxs)(t.p,{children:["For example, if you want to provide a set of players that can interact with the dialogue's contents, then you can create a fragments to contains the player states and you can grab them with some tags before you starts off the dialogue. The ",(0,a.jsx)(t.strong,{children:"player"})," fragment in the image above is great example for this."]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"dialogue-editor-graph-node",children:"Dialogue Editor Graph Node"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsxs)(t.strong,{children:["Dialogue Editor Graph Node (",(0,a.jsx)(t.code,{children:"UDialogueEdGraphNode"}),")"]})," is an editor only class for the nodes on the graph. It contains various useful features related to the customization."]}),"\n",(0,a.jsxs)(t.p,{children:["You can start creating a new graph node class by deriving ",(0,a.jsx)(t.code,{children:"UDialogueEdGraphNode"})," (If you want to make a graph node for a fragment, then you must override ",(0,a.jsx)(t.code,{children:"UDialogueEdGraphNode_Fragment"}),")."]}),"\n",(0,a.jsx)(t.p,{children:"Especially if you want to implement a dialogue node with custom pins, you must override this class in C++."}),"\n",(0,a.jsxs)(t.admonition,{type:"info",children:[(0,a.jsx)(t.p,{children:"We are not planning the make the editor node overridable in the blueprint yet."}),(0,a.jsx)(t.p,{children:"But don't be scare even if you are not familiar with the c++! It is very easy to do even if it uses code."}),(0,a.jsx)(t.p,{children:"We have a separate document about making a custom editor node for the system. Refer to Making Custom Graph Node for Dialogue Node."})]}),"\n",(0,a.jsx)(t.h3,{id:"node-instance-related",children:"Node instance Related"}),"\n",(0,a.jsxs)(t.p,{children:["Dialogue Editor Graph Nodes stores the runtime dialogue node they are referring in ",(0,a.jsx)(t.strong,{children:"NodeInstance"})," property. You can access the runtime node with that property, or you can get the type-casted version of it with ",(0,a.jsx)(t.code,{children:"GetCastedNodeInstance<>"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["If you want to specify the class of the dialogue node that your editor node supports, you can override ",(0,a.jsx)(t.code,{children:"SupportedNodeClass"})," and return the class of the dialogue node.\nThis is important to provide the exact class if you want to make the system automatically use this class when you placed a new node, ",(0,a.jsx)(t.strong,{children:"because the editor will pick up the editor node that provides the exact match class when you are placing a new node on the graph."})]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"TSubclassOf<UDialogueNodeBase> UDialogueEdFragment_Select::SupportedNodeClass()\n{\n\treturn UDF_Select::StaticClass();\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["You can override ",(0,a.jsx)(t.code,{children:"GetNodeTitleColor"})," to specify the iconic color of the nodes on the graph."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"FLinearColor UDialogueEdFragment_Select::GetNodeTitleColor() const\n{\n\treturn FLinearColor(0.4f, 0.2f, 0.5f);\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["You can override ",(0,a.jsx)(t.code,{children:"OnNodeInstancePropertyChanged"})," to attach a function that will be triggered whenever any of the properties the node instance has become changed. This is useful when you have to update some of the graph node visuals for the node instance properties"]}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsxs)(t.p,{children:["We don't recommend to attach some pin related events on there. Try using ",(0,a.jsx)(t.code,{children:"ReallocatePins"})," instead."]})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"void UDialogueEdFragment_LevelSequence::OnNodeInstancePropertyChanged(const FPropertyChangedEvent& PropertyChangedEvent,\nconst FString& PropertyName)\n{\nSuper::OnNodeInstancePropertyChanged(PropertyChangedEvent, PropertyName);\n\n\tUpdateThumbnail();\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"sub-node-related",children:"Sub Node Related"}),"\n",(0,a.jsxs)(t.p,{children:["You can override ",(0,a.jsx)(t.code,{children:"CanAttachSubNodeOnThis"})," to tell the system whether it can have the sub node (fragment) whenever a new node is trying to be attached on the node."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'FPinConnectionResponse UDialogueEdFragment_Select::CanAttachSubNodeOnThis(const UDialogueEdGraphNode* InSubNode) const\n{\n\tif (UDF_Select* Context = InSubNode->GetCastedNodeInstance<UDF_Select>())\n\t{\n\t\treturn FPinConnectionResponse(CONNECT_RESPONSE_DISALLOW,\n\t\t                              LOCTEXT("AllowedAttachmentMessage",\n\t\t                                      "Context node can not have another context node as child."));\n\t}\n\n\treturn Super::CanAttachSubNodeOnThis(InSubNode);\n}\n'})}),"\n",(0,a.jsx)(t.h3,{id:"pin-related",children:"Pin Related"}),"\n",(0,a.jsxs)(t.p,{children:["You can override ",(0,a.jsx)(t.code,{children:"AllocateDefaultPins"})," to implement the default pins for the node on the graph.\nUDialogueEdGraphNode provide a property that helps you to implement a pin on the node easily, ",(0,a.jsx)(t.strong,{children:"PinData"}),". You can use this array to implement pins for the node."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'void UDialogueEdFragment_Select::AllocateDefaultPins()\n{\n\tPinData.Empty();\n\n\tPinData.Add(FDialogueEdPinData("Out", EEdGraphPinDirection::EGPD_Output));\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"img_9.png",src:n(3663).Z+"",width:"877",height:"526"})}),"\n",(0,a.jsxs)(t.p,{children:["You can override ",(0,a.jsx)(t.code,{children:"ReallocatePins"})," to add or remove the pins on the node instance & graph node's property change."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Notice that we are trying to save the pin data that has actual implemented pin on the graph, because if we remove it then any connects with that pin will break."})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'void UDialogueEdFragment_Branch::ReallocatePins()\n{\nUDF_Branch* CastedNodeInstance = GetCastedNodeInstance<UDF_Branch>();\n\n\tif (CastedNodeInstance == nullptr) return;\n\n\t//Collect all the False pins by whether they are actually implemented or not.\n\n\tTArray<FDialogueEdPinData> NotImplementedFalsePinData;\n\tTArray<FDialogueEdPinData> FalsePinData;\n\n\n\tfor (const FDialogueEdPinData& Data : PinData)\n\t{\n\t\tif (Data.PinName == "False")\n\t\t{\n\t\t\tif (Data.ImplementedPinId == FGuid())\n\t\t\t{\n\t\t\t\tNotImplementedFalsePinData.Add(Data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFalsePinData.Add(Data);\n\t\t\t}\n\t\t}\n\t}\n\n\t//attach the NotImplementedFalsePinData at the tail so we can pop out those first.\n\tFalsePinData.Append(NotImplementedFalsePinData);\n\n\n\tif (!CastedNodeInstance->bUseFalse)\n\t{\n\t\t//Remove the false pin.\n\t\tfor (FDialogueEdPinData DialogueEdPinData : FalsePinData)\n\t\t{\n\t\t\tPinData.Remove(DialogueEdPinData);\n\t\t}\n\t}\n\telse\n\t{\n\t\t//Restore the false pin.\n\n\t\t//Pop out if we have too many of them. \n\t\twhile (FalsePinData.Num() > 1)\n\t\t{\n\t\t\tPinData.Remove(FalsePinData.Last());\n\t\t\tFalsePinData.Pop();\n\t\t}\n\n\t\tif (FalsePinData.IsEmpty())\n\t\t{\n\t\t\tPinData.Add(FDialogueEdPinData("False", EEdGraphPinDirection::EGPD_Output));\n\t\t}\n\t}\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["We have ",(0,a.jsx)(t.code,{children:"NodeConnectionListChanged"})," that will be triggered whenever any of the pins' connection list has been changed. You must override ",(0,a.jsx)(t.code,{children:"NodeConnectionListChanged"})," to collect the nodes that has been attached on the pins."]}),"\n",(0,a.jsx)(t.p,{children:"Check out the UDialogueEdFragment_Select::NodeConnectionListChanged from Joint Native and see how we are getting the connected nodes on the pin"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"void UDialogueEdFragment_Select::NodeConnectionListChanged()\n{\n\tSuper::NodeConnectionListChanged();\n\n\tUDF_Select* CastedNode = GetCastedNodeInstance<UDF_Select>();\n\n\tif (CastedNode == nullptr) return;\n\n\t//Clear the next nodes array first because will are going to reallocate them.\n\tCastedNode->NextNodes.Empty();\n\n\t//Iterate through the pins this graph node has.\n\tfor (UEdGraphPin* Pin : Pins)\n\t{\n\t\tif (Pin == nullptr) continue;\n\n\t\t//Find the replicated pin from the parent-most node.\n\t\t//This is necessary because the pins on the fragment are not implemented on the graph, instead, the parent-most node of the fragment take all the pins on the fragment and replicate them, and display on the graph.\n\t\t//So to get the connections of the pins, you must get the replicated pin and get the connection from them.\n\t\tUEdGraphPin* FoundPin = FindReplicatedSubNodePin(Pin);\n\n\t\tif (FoundPin == nullptr) continue;\n\n\t\t//Iterate through the connected pins on the replicated pin.\n\t\tfor (const UEdGraphPin* LinkedTo : FoundPin->LinkedTo)\n\t\t{\n\t\t\tif (LinkedTo == nullptr) continue;\n\n\t\t\t//Check the connected node and cast it to UDialogueEdGraphNode.\n\t\t\tif (LinkedTo->GetOwningNode() == nullptr) continue;\n\t\t\t\n\t\t\tUEdGraphNode* ConnectedNode = LinkedTo->GetOwningNode();\n\n\t\t\tif (!ConnectedNode) continue;\n\t\t\t\n\t\t\tUDialogueEdGraphNode* CastedGraphNode = Cast<UDialogueEdGraphNode>(ConnectedNode);\n\n\t\t\tif (!CastedGraphNode) continue;\n\n\t\t\t//Get the actual node instances from the connected node and allocate it on the Next Nodes.\n\t\t\t//This is necessary because the graph node itself might not have the node instances we have to get. (ex-> Connector node)\n\t\t\t//It solves such 'redirections' on the connections.\n\t\t\tCastedGraphNode->AllocateReferringNodeInstancesOnConnection(CastedNode->NextNodes);\n\t\t}\n\t}\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"graph-node-slate-related",children:"Graph Node Slate Related"}),"\n",(0,a.jsx)(t.p,{children:"In Joint, you don't have to override an actual slate class to display a custom slate on the editor."}),"\n",(0,a.jsxs)(t.p,{children:["What you have to do is to override ",(0,a.jsx)(t.code,{children:"ModifyGraphNodeSlate"}),". You can access the node's graph slate with ",(0,a.jsx)(t.code,{children:"GetGraphNodeSlate"})," there, and you can grab the existing layout and attach any slates you want on the layout."]}),"\n",(0,a.jsx)(t.p,{children:"Graph node slate provide those slates for the customization. :"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"TSharedPtr<SImage> NodeHighlightOverlay;\n\nTSharedPtr<SImage> NodeBackground;\n\t\nTSharedPtr<SBorder> NodeBody;\n\nTSharedPtr<SHorizontalBox> NameBox;\n\t\nTSharedPtr<SVerticalBox> CenterWholeBox;\n\t\nTSharedPtr<SVerticalBox> CenterContentBox;\n\t\nTSharedPtr<SWrapBox> SubNodeBox;\n\nTSharedPtr<SVerticalBox> NodeTagBox;\n\t\nTSharedPtr<SVerticalBox> PropertyDisplayBox;\n"})}),"\n",(0,a.jsx)(t.p,{children:"See how our UDialogueEdFragment_LevelSequence attach its custom slates on the graph. :"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'void UDialogueEdFragment_LevelSequence::ModifyGraphNodeSlate()\n{\n\tif (!GetGraphNodeSlate().IsValid()) return;\n\n\tconst TSharedPtr<SDialogueGraphNodeBase> NodeSlate = GetGraphNodeSlate();\n\n\tif (!GetCastedNodeInstance<UDF_LevelSequence>()) return;\n\n\tconst TAttribute<FString> AssetPath_Attr = TAttribute<FString>::Create(TAttribute<FString>::FGetter::CreateLambda(\n\t\t[this]\n\t\t{\n\t\t\tif (GetCastedNodeInstance<UDF_LevelSequence>() && GetCastedNodeInstance<UDF_LevelSequence>()->\n\t\t\t\tSequenceToPlay)\n\t\t\t{\n\t\t\t\treturn GetCastedNodeInstance<UDF_LevelSequence>()->SequenceToPlay->GetPathName();\n\t\t\t}\n\n\t\t\treturn FString();\n\t\t}));\n\n\tAssetThumbnailPool = MakeShareable(new FAssetThumbnailPool(24, true));\n\n\n\tNodeSlate->CenterContentBox->AddSlot()\n\t\t.AutoHeight()\n\t\t.HAlign(HAlign_Center)\n\t\t.VAlign(VAlign_Center)\n\t\t.Padding(FJointEditorStyle::Margin_Border)\n\t\t[\n\t\t\tSNew(SVerticalBox)\n\t\t\t\t+ SVerticalBox::Slot()\n\t\t\t\t.AutoHeight()\n\t\t\t\t.Padding(FJointEditorStyle::Margin_Frame)\n\t\t\t\t.VAlign(VAlign_Center)\n\t\t\t\t.HAlign(HAlign_Center)\n\t\t\t\t[\n\t\t\t\t\tSNew(SBorder)\n\t\t\t\t\t.Visibility(EVisibility::SelfHitTestInvisible)\n\t\t\t\t\t.Padding(FMargin(0, 0, 4, 4))\n\t\t\t\t\t.BorderImage(FAppStyle::Get().GetBrush("PropertyEditor.AssetTileItem.DropShadow"))\n\t\t\t\t\t[\n\t\t\t\t\t\tSNew(SOverlay)\n\t\t\t\t\t\t+ SOverlay::Slot()\n\t\t\t\t\t\t.Padding(1)\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tSNew(SBorder)\n\t\t\t\t\t\t\t.Padding(0)\n\t\t\t\t\t\t\t.BorderImage(FStyleDefaults::GetNoBrush())\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tSAssignNew(AssetBox, SBox)\n\t\t\t\t\t\t\t\t.WidthOverride(ThumbnailSize.X)\n\t\t\t\t\t\t\t\t.HeightOverride(ThumbnailSize.Y)\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t]\n\t\t\t\t]\n\t\t\t\t+ SVerticalBox::Slot()\n\t\t\t\t.AutoHeight()\n\t\t\t\t.Padding(FJointEditorStyle::Margin_Frame)\n\t\t\t\t.VAlign(VAlign_Center)\n\t\t\t\t.HAlign(HAlign_Center)\n\t\t\t\t[\n\t\t\t\t\tSNew(SObjectPropertyEntryBox)\n\t\t\t\t\t.DisplayBrowse(true)\n\t\t\t\t\t.EnableContentPicker(true)\n\t\t\t\t\t.AllowClear(true)\n\t\t\t\t\t.ObjectPath(AssetPath_Attr)\n\t\t\t\t\t.AllowedClass(ULevelSequence::StaticClass())\n\t\t\t\t\t.OnObjectChanged_UObject(this, &UDialogueEdFragment_LevelSequence::OnAssetSelectedFromPicker)\n\t\t\t\t]\n\t\t];\n\n\tUpdateThumbnail();\n}\n'})})]})}function c(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},2970:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/img-4ffb037f4850036961cb4f0cf5fca4a8.png"},5158:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/img_1-1863c0c389a4df81e88ae0485ca9664f.png"},6565:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/img_2-e473e69c4ad3e5417a91c09c4498d52c.png"},2243:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/img_3-7dfb4c9a47f5a3c96024d0b163ef37a9.png"},2891:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/img_4-481652c69f6827c00cc98f29535b57a4.png"},258:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/img_5-70c69cecbac8fbd0bf642476a2bec7ed.png"},80:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/img_6-c43e3cc85d097c96bb02c73d1dcbba11.png"},1745:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/img_8-826920daf863712d85a832d2984d63a9.png"},3663:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/img_9-3ff44afe0d761a553525335fd5d17150.png"},1151:(e,t,n)=>{n.d(t,{Z:()=>s,a:()=>d});var a=n(7294);const o={},i=a.createContext(o);function d(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);