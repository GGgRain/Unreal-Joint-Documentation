"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6315],{42341:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"guide_docs/Joint/Fundamentals/Working-With-Networking/Working-With-Networking","title":"Networking in Joint","description":"Learn how to work with networking in Joint, including replicated nodes, authoritative base node playback controlling, concept of automated per-client perfect playback timing controls","source":"@site/docs/guide_docs/Joint/Fundamentals/Working-With-Networking/Working-With-Networking.md","sourceDirName":"guide_docs/Joint/Fundamentals/Working-With-Networking","slug":"/guide_docs/Joint/Fundamentals/Working-With-Networking/","permalink":"/Unreal-Joint-Documentation/ko-kr/docs/guide_docs/Joint/Fundamentals/Working-With-Networking/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/guide_docs/Joint/Fundamentals/Working-With-Networking/Working-With-Networking.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Networking in Joint","description":"Learn how to work with networking in Joint, including replicated nodes, authoritative base node playback controlling, concept of automated per-client perfect playback timing controls","sidebar_position":7,"toc_min_heading_level":2,"toc_max_heading_level":6},"sidebar":"GuideSidebar","previous":{"title":"Working With GAS On Joint Actor","permalink":"/Unreal-Joint-Documentation/ko-kr/docs/guide_docs/Joint/Fundamentals/Working-With-GAS-Component-On-Joint-Actor/"},"next":{"title":"Joint Responsive Production Playback","permalink":"/Unreal-Joint-Documentation/ko-kr/docs/guide_docs/Joint/Fundamentals/Reactive-Playback-For-Different-Culture-And-Per-Client/"}}');var o=n(74848),r=n(28453);const s={title:"Networking in Joint",description:"Learn how to work with networking in Joint, including replicated nodes, authoritative base node playback controlling, concept of automated per-client perfect playback timing controls",sidebar_position:7,toc_min_heading_level:2,toc_max_heading_level:6},a=void 0,c={},l=[{value:"Node Replication",id:"node-replication",level:2},{value:"Playback State is NOT Replicated",id:"playback-state-is-not-replicated",level:3},{value:"Working Around It",id:"working-around-it",level:4},{value:"RPC Function Execution for Nodes",id:"rpc-function-execution-for-nodes",level:2},{value:"Joint Nodes CAN&#39;T Execute RPC Functions Directly",id:"joint-nodes-cant-execute-rpc-functions-directly",level:3},{value:"Working Around It",id:"working-around-it-1",level:4},{value:"Automated Per-Client Perfect Playback Timing Controls",id:"automated-per-client-perfect-playback-timing-controls",level:2},{value:"Authoritative Base Node Playback Control",id:"authoritative-base-node-playback-control",level:2},{value:"How To Prevent &quot;Skipping&quot; on Clients",id:"how-to-prevent-skipping-on-clients",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"This document will cover the traits of the networking implementation of Joint, and how you can work with it."}),"\n",(0,o.jsx)(t.h2,{id:"node-replication",children:"Node Replication"}),"\n",(0,o.jsx)(t.p,{children:"Joint provides built-in support for node replication, allowing you to synchronize the state of Joint nodes properties multiple clients in a networked environment."}),"\n",(0,o.jsxs)(t.p,{children:["It's very simple to make your Joint Node replicated - you just have to enable the ",(0,o.jsx)(t.strong,{children:"Replicates"})," property on the node class, and Joint will take care of the rest for you."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"img.png",src:n(19930).A+"",width:"1718",height:"553"})}),"\n",(0,o.jsxs)(t.p,{children:["After enabling this property, the properties marked with ",(0,o.jsx)(t.strong,{children:"Replicated"})," or ",(0,o.jsx)(t.strong,{children:"Replicated Using"})," specifiers in your node class will be automatically synchronized across the network."]}),"\n",(0,o.jsx)(t.p,{children:"What you have to do next is simply to implement the logic that utilizes the replicated properties in your node class!"}),"\n",(0,o.jsx)(t.admonition,{type:"info",children:(0,o.jsxs)(t.p,{children:["Please check out Joint Native's ",(0,o.jsx)(t.code,{children:"DF_ServerClient_WaitSkip"})," and ",(0,o.jsx)(t.code,{children:"DF_ServerClient_Vote"})," BP for the example of a replicated node."]})}),"\n",(0,o.jsx)(t.h3,{id:"playback-state-is-not-replicated",children:"Playback State is NOT Replicated"}),"\n",(0,o.jsxs)(t.p,{children:["One of the core concept you have to know is that the ",(0,o.jsx)(t.strong,{children:"playback state"})," of ",(0,o.jsx)(t.strong,{children:"fragments"})," itself is ",(0,o.jsx)(t.strong,{children:"NOT replicated."})]}),"\n",(0,o.jsxs)(t.p,{children:["This means that the Begin / End / Pending end states of fragments are managed independently on each client - but ONLY THE PROPERTIES marked as ",(0,o.jsx)(t.strong,{children:"Replicated"})," or ",(0,o.jsx)(t.strong,{children:"Replicated Using"})," are synchronized across the network."]}),"\n",(0,o.jsx)(t.p,{children:"This is totally intentional design decision for the Reactive Playback system of Joint, as it allows each client to maintain its own playback state while still being able to synchronize the necessary data across the network."}),"\n",(0,o.jsx)(t.h4,{id:"working-around-it",children:"Working Around It"}),"\n",(0,o.jsx)(t.admonition,{type:"info",children:(0,o.jsx)(t.p,{children:"If you want to control the playback state of fragments across the network, You have to implement some additional logic to do so using the replicated properties of your nodes,\nFor example, you can create a replicated property that indicates whether a fragment should be playing or not, and then use that property to control the playback state on each client on RepNotify function."})}),"\n",(0,o.jsx)(t.h2,{id:"rpc-function-execution-for-nodes",children:"RPC Function Execution for Nodes"}),"\n",(0,o.jsx)(t.p,{children:"Joint Nodes also support RPC function execution, allowing you to call functions on nodes across the network."}),"\n",(0,o.jsxs)(t.p,{children:["It's basically the same as the standard Unreal Engine RPC system - you can mark your node functions with ",(0,o.jsx)(t.strong,{children:"Server"}),", ",(0,o.jsx)(t.strong,{children:"Client"}),", or ",(0,o.jsx)(t.strong,{children:"NetMulticast"})," specifiers to indicate how they should be executed across the network."]}),"\n",(0,o.jsx)(t.h3,{id:"joint-nodes-cant-execute-rpc-functions-directly",children:"Joint Nodes CAN'T Execute RPC Functions Directly"}),"\n",(0,o.jsxs)(t.p,{children:["But there is one important thing you have to keep in mind when working with RPC functions on Joint Nodes: ",(0,o.jsx)(t.strong,{children:"Node itself CAN'T execute RPC functions directly."})]}),"\n",(0,o.jsxs)(t.admonition,{type:"info",children:[(0,o.jsx)(t.p,{children:"Unfortunately, this is due to the networking system design of the Unreal Engine itself."}),(0,o.jsxs)(t.p,{children:["Unreal's networking system is designed around with the authority model, ",(0,o.jsx)(t.strong,{children:"where only objects that the host(client, server) has authority over the object can execute RPC functions of the object."})]}),(0,o.jsxs)(t.p,{children:["If you need further details about this concept, please refer to ",(0,o.jsx)(t.a,{href:"https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Networking/",children:"Unreal Engine's official documentation about Networking and Multiplayer"}),"."]})]}),"\n",(0,o.jsx)(t.h4,{id:"working-around-it-1",children:"Working Around It"}),"\n",(0,o.jsx)(t.p,{children:"Since the clients don't have authority over the Joint Nodes (as they are owned by the Joint Actor Instance, which is typically owned by the server), they can't execute RPC functions on the nodes directly."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"So what you have to do is to use an actor that the client has authority"}),": ",(0,o.jsx)(t.strong,{children:"such as a player controller"}),". This is a common pattern in Unreal Engine networking, where the player controller acts as a bridge between the client and the server."]}),"\n",(0,o.jsxs)(t.admonition,{type:"info",children:[(0,o.jsx)(t.p,{children:"Here is an example of the best practice of how to execute RPC functions on Joint Nodes:"}),(0,o.jsxs)(t.p,{children:["In the Joint Native's Sample Contents, You can find ",(0,o.jsx)(t.code,{children:"BP_Joint_NetAuthorityHandleInterface"})," interface that declares abstract functions for executing RPC calls for ",(0,o.jsx)(t.code,{children:"DF_ServerClient_WaitSkip"})," and ",(0,o.jsx)(t.code,{children:"DF_ServerClient_Vote"}),". We used this interface as an additional layer for the abstration because we didn't want to tightly couple the Joint Node classes with the sample player controller class."]}),(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"img_2.png",src:n(97013).A+"",width:"1951",height:"1093"})}),(0,o.jsxs)(t.p,{children:["And in ",(0,o.jsx)(t.code,{children:"DF_ServerClient_WaitSkip"})," and ",(0,o.jsx)(t.code,{children:"DF_ServerClient_Vote"}),", we cast the player controller object to ",(0,o.jsx)(t.code,{children:"BP_Joint_NetAuthorityHandleInterface"})," and call the functions declared in the interface to execute the RPC calls."]}),(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"img_3.png",src:n(14124).A+"",width:"1868",height:"563"})}),(0,o.jsxs)(t.p,{children:["And in the actual player controller class, ",(0,o.jsx)(t.code,{children:"BP_JointSamplePC"}),", we inherit ",(0,o.jsx)(t.code,{children:"BP_Joint_NetAuthorityHandleInterface"})," and override the interface functions to execute the actual RPC function that will be executed on the server side, and from there, we can call the RPC functions on the Joint Nodes."]}),(0,o.jsx)(t.p,{children:"(So we're making the client's fragment to let the client's player controller to send request to the server via RPC, and the server's player controller will execute the actual RPC function on the Joint Node instead of the client.)"}),(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"img_1.png",src:n(11262).A+"",width:"1689",height:"543"})})]}),"\n",(0,o.jsx)(t.h2,{id:"automated-per-client-perfect-playback-timing-controls",children:"Automated Per-Client Perfect Playback Timing Controls"}),"\n",(0,o.jsx)(t.p,{children:"Joint provides Reactive Playback for different clients - and here is a video that explains the concept of Reactive Playback for different cultures and clients:"}),"\n",(0,o.jsx)("iframe",{width:"100%",style:{"aspect-ratio":"16 / 9"},src:"https://github.com/user-attachments/assets/5d861681-26c1-4696-95d7-25dbf227d936",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",referrerpolicy:"strict-origin-when-cross-origin",allowfullscreen:!0}),"\n",(0,o.jsx)(t.admonition,{type:"warning",children:(0,o.jsxs)(t.p,{children:["Please refer to ",(0,o.jsx)(t.a,{href:"../Fundamentals/Reactive-Playback-For-Different-Culture-And-Per-Client",children:"Reactive Playback For Different Culture & Per Client"})," and read the document to understand the concept of Reactive Playback for different clients before proceeding."]})}),"\n",(0,o.jsxs)(t.p,{children:["Key principle of this concept is that ",(0,o.jsx)(t.strong,{children:"each client manages its own playback of the fragments independently, allowing for perfect synchronization of content regardless of the networking situation."})]}),"\n",(0,o.jsx)(t.p,{children:"This is why the playback state of fragments is not replicated across the network - because each client needs to manage its own playback state independently to achieve perfect timing for each client."}),"\n",(0,o.jsx)(t.h2,{id:"authoritative-base-node-playback-control",children:"Authoritative Base Node Playback Control"}),"\n",(0,o.jsxs)(t.p,{children:["Even though the playback state of fragments is not replicated across the network, ",(0,o.jsx)(t.strong,{children:"Joint needs and provides a way to sync out and control the overall playback of the Joint Manager."})]}),"\n",(0,o.jsx)(t.p,{children:"Joint solve this issue by letting only the host(server or client) that has authority over the Joint Actor Instance to control the playback of the Base Nodes (such as Foundation Node), and the other clients' base nodes' playback state will follow the playback state the base nodes of the authoritative host."}),"\n",(0,o.jsx)(t.p,{children:"This is absolute rule - if the authoritative host pauses, skips, or stops the base nodes, the clients will do the same."}),"\n",(0,o.jsx)(t.h3,{id:"how-to-prevent-skipping-on-clients",children:'How To Prevent "Skipping" on Clients'}),"\n",(0,o.jsx)(t.p,{children:'But one problem is, this means that clients with no authority can experience some "skipping" on the playback - for example, if the authoritative host skips a base node while the client didn\'t finish playing the fragments on the base node, the client will immediately ends all the fragments that were being played and move on to the next base node.'}),"\n",(0,o.jsxs)(t.p,{children:['Preventing this "skipping" behavior is actually very simple - ',(0,o.jsx)(t.strong,{children:"you just have to make sure that the authoritative host only skips or moves on to the next base node when all clients are ready to do so."})]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsxs)(t.strong,{children:['One of the best practices to achieve this is to implement a "ready check" system using replicated properties on your Joint Nodes - Which is exactly what Joint Native\'s ',(0,o.jsx)(t.code,{children:"DF_ServerClient_WaitSkip"})," node does."]})}),"\n",(0,o.jsx)(t.p,{children:'This node checks and waits til enough number of players press "skip" button and say "ready" to proceed, and only when the required number of players are ready, this fragment will end and allow the base node to move on to the next one.'})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},19930:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/img-b27143fe980a3e351934487c39cd8eb4.png"},11262:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/img_1-4428929a8bdfe73d57df134b1798e357.png"},97013:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/img_2-36ad3bc48472ab4c7d400fbb3494f3e4.png"},14124:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/img_3-f1d8a53dfeb25640cd9658ee73ffbbb1.png"},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var i=n(96540);const o={},r=i.createContext(o);function s(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);