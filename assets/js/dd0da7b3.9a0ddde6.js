"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9750],{68350:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"guide_docs/Joint/Fundamentals/Node-Lifecycle/Node-Lifecycle","title":"Node Execution Chain & Node Lifecycle","description":"Learn the core principles of Joint, Node lifecycle.","source":"@site/docs/guide_docs/Joint/Fundamentals/Node-Lifecycle/Node-Lifecycle.md","sourceDirName":"guide_docs/Joint/Fundamentals/Node-Lifecycle","slug":"/guide_docs/Joint/Fundamentals/Node-Lifecycle/","permalink":"/Unreal-Joint-Documentation/docs/guide_docs/Joint/Fundamentals/Node-Lifecycle/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/guide_docs/Joint/Fundamentals/Node-Lifecycle/Node-Lifecycle.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Node Execution Chain & Node Lifecycle","description":"Learn the core principles of Joint, Node lifecycle.","sidebar_position":3,"toc_min_heading_level":2,"toc_max_heading_level":6},"sidebar":"GuideSidebar","previous":{"title":"Controlling Graph Playback Flow","permalink":"/Unreal-Joint-Documentation/docs/guide_docs/Joint/Fundamentals/Playback-Flow/"},"next":{"title":"Finding Nodes And Fragments","permalink":"/Unreal-Joint-Documentation/docs/guide_docs/Joint/Fundamentals/Finding-Nodes-And-Fragments/"}}');var i=t(74848),a=t(28453);const r={title:"Node Execution Chain & Node Lifecycle",description:"Learn the core principles of Joint, Node lifecycle.",sidebar_position:3,toc_min_heading_level:2,toc_max_heading_level:6},s=void 0,d={},l=[{value:"Video Explanation",id:"video-explanation",level:2},{value:"Chain of Node Execution",id:"chain-of-node-execution",level:2},{value:"Manager Fragments are Played First, And End Last",id:"manager-fragments-are-played-first-and-end-last",level:3},{value:"Base Nodes Plays Fragments",id:"base-nodes-plays-fragments",level:3},{value:"Fragments Will Play Their Sub Fragments",id:"fragments-will-play-their-sub-fragments",level:3},{value:"Node&#39;s Life Cycle Stages",id:"nodes-life-cycle-stages",level:2},{value:"Pre &amp; Post Begin Play",id:"pre--post-begin-play",level:3},{value:"Pre &amp; Post End Play",id:"pre--post-end-play",level:3},{value:"Pre &amp; Post Pending",id:"pre--post-pending",level:3}];function c(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.admonition,{type:"important",children:(0,i.jsx)(n.p,{children:"This document covers the core principles of Joint Framework. It is highly recommended to read this document carefully before creating your own custom nodes or fragments."})}),"\n",(0,i.jsx)(n.p,{children:"Joint's fragment based architecture was possible because of this unique design on the lifecycle of nodes."}),"\n",(0,i.jsx)(n.p,{children:"Understanding the lifecycle of nodes is extremely important to utilize Joint Framework, as it will help you understand how Joint works under the hood, and also help you to create your own custom nodes and fragments that works perfectly with Joint system."}),"\n",(0,i.jsx)(n.h2,{id:"video-explanation",children:"Video Explanation"}),"\n",(0,i.jsx)(n.p,{children:"The whole concept is also explained in the following video. This will greatly help you understand the concept, so please make sure to check it out!"}),"\n",(0,i.jsx)("iframe",{width:"100%",style:{"aspect-ratio":"16 / 9"},src:"https://www.youtube.com/embed/hODzi1OK3wg?si=ZUN17WrFfaP6P9uN&start=2646",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",referrerpolicy:"strict-origin-when-cross-origin",allowfullscreen:!0}),"\n",(0,i.jsx)(n.h2,{id:"chain-of-node-execution",children:"Chain of Node Execution"}),"\n",(0,i.jsx)(n.p,{children:"First of all, let's see how the node execution flows in Joint Framework."}),"\n",(0,i.jsx)(n.h3,{id:"manager-fragments-are-played-first-and-end-last",children:"Manager Fragments are Played First, And End Last"}),"\n",(0,i.jsx)(n.p,{children:"Manager fragments are special fragments that are attached to the Joint Manager instead of the base nodes. (accomplished through attaching fragments on the root node of the Joint Manager)"}),"\n",(0,i.jsx)(n.p,{children:"One of the biggest traits of Manager fragment is that they will be played when the Joint Actor instance begins played, and will be ends when the Joint Actor instance ends played."}),"\n",(0,i.jsx)(n.p,{children:"In other words, Manager fragments will keep being active throughout the Joint."}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Thus, You can use manager fragments to implement some logics that should constantly work in the whole Joint, such as calculating the Joint widget's location etc."})}),(0,i.jsx)(n.p,{children:"Plus, Manager Fragments are the most effective methods for data storages that can be used throughout the playback, since their life-cycle will follow the Joint instance's life-cycle and they are the easiest fragments to find on the graph on the performance wise."})]}),"\n",(0,i.jsx)(n.h3,{id:"base-nodes-plays-fragments",children:"Base Nodes Plays Fragments"}),"\n",(0,i.jsx)(n.p,{children:"After playing the manager fragments, Joint Actor will begin to play the start base node that is connected to the Joint Manager's root node."}),"\n",(0,i.jsx)(n.p,{children:"This base node will be played as the first base node of the Joint instance, and from here the playback will continue according to the playback flow of the nodes."}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"Please note that only one base node can be played at the same time in a Joint Actor instance. (unlike fragments, which can be played multiple at the same time)"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"When the Joint Actor instance ends played in the middle of the playback, it will end play all the base nodes that are currently being played."})}),"\n",(0,i.jsxs)(n.p,{children:["Base nodes also have a full lifecycle that consists of ",(0,i.jsx)(n.code,{children:"Begin Play"}),", ",(0,i.jsx)(n.code,{children:"End Play"}),", and ",(0,i.jsx)(n.code,{children:"Pending"})," states, just like fragments (explained later), and what we have to see is how the ",(0,i.jsx)(n.code,{children:"PostNodeBeginPlay"})," works on the base nodes."]}),"\n",(0,i.jsxs)(n.p,{children:["On ",(0,i.jsx)(n.code,{children:"PostNodeBeginPlay"})," of the base nodes, it will check whether it has any sub nodes (fragments) to play, and if it has, it will play the sub nodes with ",(0,i.jsx)(n.code,{children:"SubNodesBeginPlay"}),". If not, it will end play itself immediately to prevent hanging nodes."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"void UJointNodeBase::PostNodeBeginPlay_Implementation()\r\n{\r\n\tSubNodes.Remove(nullptr);\r\n\t\r\n\tif (!SubNodes.IsEmpty())\r\n\t{\r\n\t\t//Play sub nodes if it has.\r\n\r\n\t\tSubNodesBeginPlay();\r\n\t}\r\n\telse\r\n\t{\r\n\t\t//End play if there is no action specified. To prevent this, you must override this function and implement the features you want for this node type.\r\n\r\n\t\tRequestNodeEndPlay();\r\n\t}\r\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"SubNodesBeginPlay"})," function simply iterates the sub nodes and request begin play for each of them."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"void UJointNodeBase::SubNodesBeginPlay()\r\n{\r\n\t//Propagate BeginPlay action to the children nodes. if it is not necessary or need some other actions for the node class, replace it with something else.\r\n\tfor (UJointNodeBase* SubNode : SubNodes)\r\n\t{\r\n\t\tif (SubNode == nullptr) continue;\r\n\r\n\t\tSubNode->RequestNodeBeginPlay(GetHostingJointInstance());\r\n\t}\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"So the important thing we have to see is that, when the base node begins played, it will also begin play all the fragments that are currently being played under the base node."})}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsx)(n.p,{children:"Vice versa, when the base node ends played, it will also end play all the fragments that are currently being played under the base node. See the code below:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"void UJointNodeBase::PostNodeEndPlay_Implementation()\r\n{\r\n\tSubNodesEndPlay();\r\n}\n"})})]}),"\n",(0,i.jsx)(n.h3,{id:"fragments-will-play-their-sub-fragments",children:"Fragments Will Play Their Sub Fragments"}),"\n",(0,i.jsxs)(n.p,{children:["So, after the base node begins played and plays its sub nodes (fragments), ",(0,i.jsxs)(n.strong,{children:["those fragments will also begin play their own sub fragments in the same way by the default behavior of ",(0,i.jsx)(n.code,{children:"PostNodeBeginPlay"}),"."]})]}),"\n",(0,i.jsx)(n.p,{children:"(Brought it here again to make it easy to see)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"void UJointNodeBase::PostNodeBeginPlay_Implementation()\r\n{\r\n\tSubNodes.Remove(nullptr);\r\n\t\r\n\tif (!SubNodes.IsEmpty())\r\n\t{\r\n\t\t//Play sub nodes if it has.\r\n\r\n\t\tSubNodesBeginPlay();\r\n\t}\r\n\telse\r\n\t{\r\n\t\t//End play if there is no action specified. To prevent this, you must override this function and implement the features you want for this node type.\r\n\r\n\t\tRequestNodeEndPlay();\r\n\t}\r\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["That default behavior of ",(0,i.jsx)(n.code,{children:"PostNodeBeginPlay"})," is applied to every node type by default, and it creates a pattern of node execution order like this:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"img.png",src:t(55424).A+"",width:"906",height:"719"})}),"\n",(0,i.jsxs)(n.p,{children:["If you're familiar with tree structures, ",(0,i.jsx)(n.strong,{children:"you can see that this is a typical depth-first traversal of tree structure."})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["But the important point of Joint is that you can override this default behavior of ",(0,i.jsx)(n.code,{children:"PostNodeBeginPlay"}),", and put your own logic to control how the sub nodes are played."]})}),"\n",(0,i.jsx)(n.h2,{id:"nodes-life-cycle-stages",children:"Node's Life Cycle Stages"}),"\n",(0,i.jsx)(n.p,{children:"We're going to take a closer look at each stage of the node lifecycle now - and learn how each stage works, and how you can control the behavior of each stage by overriding the default behavior."}),"\n",(0,i.jsx)(n.h3,{id:"pre--post-begin-play",children:"Pre & Post Begin Play"}),"\n",(0,i.jsxs)(n.p,{children:["When a node has been executed, It enters ",(0,i.jsx)(n.code,{children:"Begin Play"})," state."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Begin Play"})," action consists of two stages: ",(0,i.jsx)(n.code,{children:"PreNodeBeginPlay"})," and ",(0,i.jsx)(n.code,{children:"PostNodeBeginPlay"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Here is the actual code of ",(0,i.jsx)(n.code,{children:"NodeBeginPlay"})," function, you can see that it first calls ",(0,i.jsx)(n.code,{children:"PreNodeBeginPlay"}),", then broadcasts the delegate, notifies the hosting Joint instance, and finally calls ",(0,i.jsx)(n.code,{children:"PostNodeBeginPlay"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"The reason why it has 2 stages is to provide a way to implement logic that should be executed before and after the node begin play action respectively."})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"void UJointNodeBase::NodeBeginPlay()\r\n{\r\n\t//Don't play again if once played before.\r\n\tif (IsNodeBegunPlay()) return;\r\n\r\n\tbIsNodeBegunPlay = true;\r\n\r\n\tPreNodeBeginPlay();\r\n\t\r\n\tif (OnJointNodeBeginDelegate.IsBound())\r\n\t{\r\n\t\tOnJointNodeBeginDelegate.Broadcast(this);\r\n\t}\r\n\t\r\n\tGetHostingJointInstance()->NotifyNodeBeginPlay(this);\r\n\r\n\tPostNodeBeginPlay();\r\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["And here is the default implementation of ",(0,i.jsx)(n.code,{children:"PreNodeBeginPlay"})," and ",(0,i.jsx)(n.code,{children:"PostNodeBeginPlay"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"void UJointNodeBase::PreNodeBeginPlay_Implementation()\r\n{\r\n}\r\n\r\n\r\nvoid UJointNodeBase::PostNodeBeginPlay_Implementation()\r\n{\r\n\tSubNodes.Remove(nullptr);\r\n\t\r\n\tif (!SubNodes.IsEmpty())\r\n\t{\r\n\t\t//Play sub nodes if it has.\r\n\r\n\t\tSubNodesBeginPlay();\r\n\t}\r\n\telse\r\n\t{\r\n\t\t//End play if there is no action specified. To prevent this, you must override this function and implement the features you want for this node type.\r\n\r\n\t\tRequestNodeEndPlay();\r\n\t}\r\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here is one example of overriding the ",(0,i.jsx)(n.code,{children:"PostNodeBeginPlay"})," to implement a sequence node behavior:"]}),"\n",(0,i.jsx)(n.p,{children:"Joint's node will be triggered without waiting the previous node to finish by default. It means that the begin play action of the Joint Nodes is not delayed by the other nodes by default."}),"\n",(0,i.jsx)(n.p,{children:"To achieve the delay effect on the node execution you override the default action on begin play. This is already implemented through the Sequence Node on Joint Native."}),"\n",(0,i.jsx)(n.p,{children:"See how we implemented that feature on the sequence node."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"void UDF_Sequence::SelectNodeAsPlayingNode(UJointNodeBase* SubNode)\r\n{\r\n\tSubNode->OnJointNodeMarkedAsPendingDelegate.AddDynamic(this, &UDF_Sequence::OnSubNodePending);\r\n\r\n\tGetHostingJointInstance()->RequestNodeBeginPlay(SubNode);\r\n}\r\n\r\nvoid UDF_Sequence::PlayNextSubNode()\r\n{\r\n\tif (!GetHostingJointInstance().IsValid()) return;\r\n\r\n\tCurrentIndex++;\r\n\r\n\twhile (SubNodes.IsValidIndex(CurrentIndex))\r\n\t{\r\n\t\tUJointNodeBase* SubNode = SubNodes[CurrentIndex];\r\n\r\n\t\tif (SubNode != nullptr)\r\n\t\t{\r\n\t\t\tSelectNodeAsPlayingNode(SubNode);\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tCurrentIndex++;\r\n\t}\r\n\r\n\r\n\tif (!SubNodes.IsValidIndex(CurrentIndex))\r\n\t{\r\n\t\tGetHostingJointInstance()->RequestNodeEndPlay(this);\r\n\t}\r\n}\r\n\r\n\r\nvoid UDF_Sequence::OnNodeBeginPlay_Implementation()\r\n{\r\n\t//reset\r\n\tCurrentIndex = INDEX_NONE;\r\n\t\r\n\tPlayNextSubNode();\r\n}\r\n\r\nvoid UDF_Sequence::OnSubNodePending(UJointNodeBase* InNode)\r\n{\r\n\tif (InNode == nullptr) return;\r\n\r\n\tInNode->OnJointNodeMarkedAsPendingDelegate.RemoveDynamic(this, &UDF_Sequence::OnSubNodePending);\r\n\r\n\tPlayNextSubNode();\r\n}\r\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pre--post-end-play",children:"Pre & Post End Play"}),"\n",(0,i.jsxs)(n.p,{children:["When a node has finished its action, It enters ",(0,i.jsx)(n.code,{children:"End Play"})," state."]}),"\n",(0,i.jsx)(n.p,{children:"And End Play of the Joint Nodes are almost identical with the begin play action. It iterates the sub nodes on hierarchy in the same order, and trigger NodeEndPlay()."}),"\n",(0,i.jsxs)(n.p,{children:["Here is the ",(0,i.jsx)(n.code,{children:"PreNodeEndPlay"})," and ",(0,i.jsx)(n.code,{children:"PostNodeEndPlay"})," default implementation."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"void UJointNodeBase::PreNodeEndPlay_Implementation()\r\n{\r\n}\r\n\r\nvoid UJointNodeBase::PostNodeEndPlay_Implementation()\r\n{\r\n\tSubNodesEndPlay();\r\n}\r\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pre--post-pending",children:"Pre & Post Pending"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Pending"})," means the state of node that has played all the necessary logic to execute, ready to finish the node playback anytime the parent node want,\r\nand no longer holding the playback."]}),"\n",(0,i.jsx)(n.p,{children:"This is useful when you want to make a node that must continue its action until the whole node ends, but don't want to halt or hold the playback."}),"\n",(0,i.jsxs)(n.p,{children:["You can mark the node as pending by force by executing ",(0,i.jsx)(n.code,{children:"MarkNodePendingByForce()"})," on the runtime."]}),"\n",(0,i.jsx)(n.p,{children:"And nodes will be marked as pending whenever they become end played."}),"\n",(0,i.jsx)(n.p,{children:"Also, Nodes will be tested whether to be marked as pending whenever any of the sub nodes (fragments) is marked as pending."}),"\n",(0,i.jsxs)(n.p,{children:["And by default, it will be marked as pending when all the sub nodes are marked as pending, and you can control this behavior by overriding ",(0,i.jsx)(n.code,{children:"MarkNodePendingIfNeeded"})," function."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"void UJointNodeBase::MarkNodePendingIfNeeded()\r\n{\r\n\tif (CheckCanMarkNodeAsPending())\r\n\t{\r\n\t\t//Mark pending.\r\n\t\tMarkNodePendingByForce();\r\n\t}\r\n}\r\n\r\n...\r\n\r\n\r\nbool UJointNodeBase::CheckCanMarkNodeAsPending_Implementation()\r\n{\r\n\tfor (const UJointNodeBase* SubNode : SubNodes)\r\n\t{\r\n\t\tif (!SubNode) continue;\r\n\r\n\t\tif (!SubNode->IsNodePending())\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},55424:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/img-9d91de34f87a96b69d0b565418ab9995.png"},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var o=t(96540);const i={},a=o.createContext(i);function r(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);